---
title: 'Prepare FUMBBL roster data'
author: "Gertjan Verhoeven & Hiliadan"
date: '2025-08-19'
params:
  group_name: "Super League S6"
  tournament_ruleset: "EB25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Creating the plots

I switched to R For further processing of the data (including clustering) and creating the final roster visualizations. Full code is available in `create_plots.Rmd`. Processing of the data involved:

* adding the cost for each player and inducement (yes, I typed together a file with the cost of all the BB2020 rosters!), 
* creating a table with all the skill colors, 
* removing the bribes from the inducements that originated from the "Get the ref" kickoff event (but keeping those that are part of the roster)
* applying a hierarchical clustering algorithm (`hclust_order()` from my own wrapper package `ggoheatmap`) to create a sort order for the rosters.

I used `ggplot` create the final plots. For ease of sharing, I created `roster_book.Rmd` that generates a PDF that contains all 29 plots.

# I. Loading package and data
## Load packages

```{r}
# Load packages
library(tidyverse)
library(ggfortify)
library(ggrepel)
library(readODS)
library(gridExtra)
library(stringr)
library(janitor)
library(reactable)
library(htmltools) # for tagList()
library(reactablefmtr) # DO NOT USE THE CRAN VERSION IT IS OUTDATED
#webshot::install_phantomjs()
#Sys.setenv(OPENSSL_CONF="/dev/null") 
#devtools::install_github("kcuilla/reactablefmtr") THIS VERSION ALSO HAS A BUG WITH A PR FIX OPEN
```


## Read the data

We start with reading in the scraped FUMBBL roster data, this is generated by the `fumbbl_rosters` Jupyter Notebook.


```{r}
group_name <- params$group_name

if(group_name == "EB25 training") {
  df_rosters1 <- read.csv(file = "../datasets/v0.7/df_rosters_eb2025.csv")
} else if (group_name == "Super League S6") {
  df_rosters1 <- read.csv(file = "../datasets/v0.8/df_rosters_super_league_s6.csv")
  df_naf_ids <- read.csv(file = "../datasets/v0.8/df_rosters_super_league_s6_naf_ids.csv")
}

df_rosters1$group_name <- group_name

# Cf. bb_tournament_settings.ods
tournament_ruleset <- params$tournament_ruleset

## Load the data downloaded from https://member.thenaf.net/glicko/nafstat-tmp-name.zip. They will be used for stats on ELO ranking etc.
NAF_coachranking_variant <- read.csv(file = "../datasets/NAF-dump/naf_coachranking_variant.csv", sep = ";")
NAF_race <- read.csv(file = "../datasets/NAF-dump/naf_race.csv", sep = ";")
NAF_variant <- read.csv(file = "../datasets/NAF-dump/naf_variants.csv", sep = ";")

## Load the global ELO from https://bloodbowl.dk/coach-rating/, provided by Tripleskull
globalcoachranking <- read.table(file = "../datasets/dk-ranking/WorldCR.txt", header = TRUE, sep = ";")

# Open the ruleset settings
allowed_inducements <- read_ods("bb_tournament_settings.ods", sheet="allowed_inducements") %>% 
  filter(Ruleset == tournament_ruleset)

banned_star_players <- read_ods("bb_tournament_settings.ods", sheet="banned_star_players") %>% 
  filter(Ruleset == tournament_ruleset)

other_settings <- read_ods("bb_tournament_settings.ods", sheet="other-settings") %>% 
  filter(Ruleset == tournament_ruleset)

max_skills <- other_settings %>%
  filter(`Other settings` == "Maximum number of same skill") %>%
  pull(Value) %>%
  as.numeric()

variant <- other_settings %>%
  filter(`Other settings` == "Variant") %>%
  pull(Value)

tournament_ordering <- read_ods("bb_tournament_settings.ods", sheet="tournament_structure")
```
# II. Data cleaning
## Beginning of data cleaning

```{r}
df_rosters <- df_rosters1 %>%
  filter(position != "") %>%
  mutate(cnt = 1) %>%
  rename(skill_name = name)
```


## Adding info on inducements etc
```{r}
# add xtra stuff
extra_stuff <- unique(df_rosters %>% 
                    mutate(apothecary = ifelse(apothecary == "Yes", 1, 0)) %>%
  select(group_name, team_id, roster.name, coach_name, rerolls, assistantCoaches, cheerleaders, apothecary) %>%
    pivot_longer(cols = -c(group_name, team_id, roster.name, coach_name), values_to = "cnt") %>%
    filter(cnt > 0) %>%
    mutate(position = name) %>%
    select(group_name, team_id, roster.name, coach_name, position, cnt) %>%
    mutate(player_id = 99999999) %>%
    mutate(number = 99) %>%
    mutate(skill_id = NA) %>%
    mutate(name = NA)) %>%
    rename(skill_name = name)

# if(group_name == "Super League S6") {
#   extra_stuff <- extra_stuff %>%
#     mutate(team_name = "")
# }

df_rosters <- df_rosters %>%
  select(-c(X, rerolls, assistantCoaches, cheerleaders, apothecary))

# Remove columns that are in the SL6 .csv but are not used later in the code and are not present in extra_stuff
if(group_name == "Super League S6") {
  df_rosters <- df_rosters %>%
    select(-c(team_name, tournament_id, tournament_name))
}

df_rosters <- rbind(df_rosters, extra_stuff)
```



## Filter out "illegal" teams


```{r remove-illegal-teams}
# Exclude non valid rosters according to the ruleset

# Identify illegal teams

# ---  Due to banned star players ---
# Create a list of team_ids associated with banned star players
banned_teams_due_to_star_players <- df_rosters %>%
  semi_join(banned_star_players, by = c("position" = "Banned star players")) %>%
  distinct(team_id)

# Add a "banned" column to df_rosters and fill it
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_star_players %>% mutate(banned_due_to_star_player = TRUE), by = "team_id")

# ---  Due to inducements not in the list ---
# Create a regex pattern from allowed inducements
allowed_patterns <- paste(allowed_inducements$Inducements, collapse = "|")

# Create a list of team_ids associated with inducements not allowed
banned_teams_due_to_other_inducements <- df_rosters %>%
  # Keep only rows which are inducements, i.e. i) number = 99, ii) not empty, iii) is not a star player 
  filter(number == 99 & !is.na(position) & !startsWith(position, "Star player")) %>% 
  # If the inducement name (stored in position) is not within the allowed_patterns, then it's illegal
  filter(is.na(str_extract(position, regex(allowed_patterns, ignore_case = TRUE)))) 

# Inducements not allowed spotted
print(banned_teams_due_to_other_inducements %>% distinct(position))


banned_teams_due_to_other_inducements <- banned_teams_due_to_other_inducements %>%
  distinct(team_id)

head(banned_teams_due_to_other_inducements,20)


# Fill the "banned" column in df_rosters
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_other_inducements %>% mutate(banned_due_to_inducements = TRUE), by = "team_id")


display <- df_rosters %>% filter(banned_due_to_inducements == TRUE)
head(display, 20)

# ---  Due to number of illegal number of skills ---
# Would need to be improved to look at inherent skills AND "purchased" skills. Currently only look at "purchased" skills.

# Count the number of skills "purchased" per team
n_skills_per_team <- df_rosters %>%
  group_by(team_id, skill_name) %>% 
  filter(skill_name != "") %>% 
  summarize(n_skills = n(), .groups = "drop")

head(n_skills_per_team)

banned_teams_due_to_number_of_skills <- n_skills_per_team %>%
  filter(n_skills > max_skills) %>%
  distinct(team_id)

head(banned_teams_due_to_number_of_skills)

# Fill the "banned" column in df_rosters
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_number_of_skills %>% mutate(banned_due_to_number_of_skills = TRUE), by = "team_id")


# --- Exclusion by hand (to deprecate) ---
df_rosters <- df_rosters %>%
  filter(!(team_id %in% c(1206955, 1209079)))


# Filter out BB2016 teams (Bretonnian)
df_rosters <- df_rosters %>%
  filter(roster.name != "Bretonnian")

```

## Label old and new amazon, and old and new norse rosters


```{r}
 old_amazon_team_ids <- df_rosters %>% filter(position == "Koka Kalim Blitzer") %>%
  filter(roster.name != "Amazon Eurobowl 2022") %>%
  group_by(team_id) %>%
  summarise(n()) %>%
  pull(team_id)
```   

```{r}
df_rosters <- df_rosters %>% 
  mutate(roster.name = ifelse(team_id %in% old_amazon_team_ids, "Amazon Team of Legend", roster.name))
```

There are also rosters with Norse Catcher AND Norse Raider. (old/new) march 2022, roster id 5144. This roster contains 

```{r}
 old_norse_team_ids <- df_rosters %>% filter(position %in% c("Norse Thrower", "Norse Catcher", "Norse Lineman")) %>%
  filter(roster.name != "Norse Eurobowl 2022") %>%
  group_by(team_id) %>%
  summarise(n()) %>%
  pull(team_id)
```

```{r}
df_rosters <- df_rosters %>% 
  mutate(roster.name = ifelse(team_id %in% old_norse_team_ids, "Norse Teams of Legend", roster.name))
```


```{r}
df_rosters %>% 
  filter(grepl("Amazon", roster.name)) %>%
  group_by(roster.name, position) %>%
  summarise(n = n())
```

## Check rosters without skills

```{r}
df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  mutate(has_skills = ifelse(n_skills == 0, 0, 1)) %>%
  group_by(group_name) %>%
  summarise(perc = mean(has_skills))
```

## Drop teams without skills.

```{r}
teams_to_drop <- df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  filter(n_skills == 0) %>%
  pull(team_id)

```
```{r}
df_rosters <- df_rosters %>%
  filter(!(team_id %in% teams_to_drop))
```


## Cleanup the skill names

```{r}
df_rosters <- df_rosters %>%
  mutate(skill_name = str_replace_all(skill_name, 
            pattern = "^_", replacement = "")) %>%
  mutate(skill_name = replace_na(skill_name, ""))
```

## condense skill stacking rows

A player with two skills has two rows, collapse into one, concatenating the two skills.
We sort by skill_id to avoid mirror combinations.

```{r}
df_rosters <- df_rosters %>%
  arrange(player_id, -skill_id) %>%
  group_by(across(c(-skill_id, -skill_name))) %>%
  summarise(skill_name = paste(skill_name, collapse = ""))

```
## wrangle bribes into cnt 0-3 bribes

Cannot easily seperate out the GEt the ref bribes from the  roster bribes

```{r}
df_rosters %>% 
  ungroup() %>%
  filter(grepl("bribe", position)) %>%
  distinct(position) %>%
  pull()

```

```{r}
df_rosters <- df_rosters %>%
  mutate(cnt = ifelse(grepl("bribe", position), as.integer(substr(position, 1, 2)), cnt)) %>%
  mutate(position = ifelse(grepl("bribes", position), "1 bribe", position)) 
```

## Open the skill color table

```{r}
skill_colors <- read_ods("230218 bb_skill_colors.ods")

skill_colors <- skill_colors %>%
  mutate(skill_name = replace_na(skill_name, "")) %>%
  select(-n)
```

# III. Stats
## Produce stats on the number of skills in the teams assessed and check missing color in the color table

The skill_colors.ods should then be checked manually for any NA (or empty) in the color column. The rows concerned should be added to 230218 bb_skill_colors.ods

```{r}
skill_stats_and_missing_colors <- df_rosters %>%
  group_by(skill_name) %>%
  summarise(n = n()) %>% 
  full_join(skill_colors, by = "skill_name")


write_ods(skill_stats_and_missing_colors, "skill_colors.ods")
```

## Produce stats of ELO values of coaches by tournament
```{r}
# Get coach's NAF ID ranking from NAF data for all the coaches in the roster dataset
df_coach_per_tournament <- unique(df_rosters1 %>%
                                    filter(group_name == group_name) %>% 
                                    select(coach_name, tournament_name, roster.name)) %>%
  left_join(df_naf_ids, by = c("coach_name" = "fumbbl_coach_name")) %>% 
  # Remove coaches not in a tournament_name (probably joined a group but didn't apply for a tournament)
  filter(tournament_name != "") %>% 
  # Rename "Super League S6 EU Swiss B R2-7" into "Super League S6 EU Swiss B" as apparently coaches are either in one or the other in the data
  mutate(tournament_name = ifelse(tournament_name == "Super League S6 EU Swiss B R2-7", "Super League S6 EU Swiss B", tournament_name))


# Get variant's ID corresponding to the tournament's variant
variant_id <- NAF_variant %>% 
  filter(variantname == variant) %>% 
  select(variantid) %>% 
  as.numeric()

# Get coach's ELO score for the race played in the tournament from NAF data
df_ELO_for_played_race_per_coach <- df_coach_per_tournament %>% 
  left_join(NAF_race, by = c("roster.name" = "name")) %>% 
  left_join(NAF_coachranking_variant %>% 
              filter(variantID == variant_id), 
            by = c("naf_id" = "coachID", "raceid" = "raceID")) %>% 
  arrange(tournament_name, -ranking) %>% 
  select(coach_name, tournament_name, roster.name, naf_id, ranking)
  

# Get coach's best ELO score across all races
best_ELO_per_coach <- NAF_coachranking_variant %>%
  filter(variantID == variant_id) %>%
  group_by(coachID) %>%
  slice_max(ranking, n = 1, with_ties = FALSE) %>%
  ungroup() %>% 
  select(coachID, ranking) %>% 
  rename(best_ranking = ranking)

# Add that best ELO to df_ELO_for_played_race_per_coach
df_ELO_for_played_race_per_coach <- df_ELO_for_played_race_per_coach %>% 
  left_join(best_ELO_per_coach, by = c("naf_id" = "coachID")) %>% 
  # Add global ranking too
  left_join(globalcoachranking, by  = c("naf_id" = "Naf.ID")) %>% 
  left_join(tournament_ordering, by  = c("tournament_name" = "tournament_name"))

write.csv(df_ELO_for_played_race_per_coach, "../shinyapps/SL6_ELO-stats/ELO_for_played_race_per_coach.csv")

```



# IV. Preparation of display
## IV.1. Preparation for the heatmaps
### create code list with roster cost

create empty list with all roster positions for each race
```{r}

out <- df_rosters %>%
  group_by(position, roster.name) %>%
  summarise(n = n())

```
manually fill in cost and sort order

### add codelist with roster cost

```{r}
cost <- read_ods("230217_bb_rosters_cost.ods")

cost <- cost %>%
  select(-n)
```

### check for missings

check if dataset has new positionals or star players etc.

```{r}
out <- out %>% 
  left_join(cost, by = c("position", "roster.name"))
```

```{r, eval = FALSE}
write_ods(out, "bb_rosters.ods")
```


```{r}
df_rosters <- df_rosters %>%
  left_join(cost, by = c("position", "roster.name"))
```


### Check team cost

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

res %>% filter(team_cost > 1150)

```

### remove bribes for TV >1150


all teams with 50 or 100 extra, remove 1 bribe ("get the ref" kick off result ends up on the match page)

```{r}
teams_get_the_ref <- res %>%
  filter(team_cost > 1150) %>%
  ungroup() %>%
  distinct(team_id) %>%
  pull()
```

reduce nr of bribes for get the ref teams with 1

<!-- So there are 22 get the ref teams -->

```{r}
df_rosters %>%
  ungroup() %>%
  filter(position == "1 bribe") %>%
  summarise(sum(cnt))
```
<!-- expect 45 - 22 = 23 bribes left -->

```{r}
# remove the get the ref bribes

df_rosters <- df_rosters %>%
  mutate(cnt = ifelse(team_id %in% teams_get_the_ref & position == "1 bribe", cnt - 1, cnt))

```


```{r}
df_rosters %>%
  ungroup() %>%
  filter(position == "1 bribe") %>%
  summarise(sum(cnt))
```
check!

drop rows with cnt 0

```{r}
df_rosters <- df_rosters %>% 
  filter(cnt != 0)
```


### Check total team cost again

Expect all teams at max 1150 or slightly below.

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

summary(res$team_cost)

```

```{r}
res %>% filter(team_cost < 1135)
```


```{r}
df_rosters <- df_rosters %>%
  left_join(skill_colors, by = "skill_name")
```

```{r}
duplicated(skill_colors$skill_name)
# "TackleStrip ball" is duplicated

```

```{r}
saveRDS(df_rosters, "work/df_rosters_prepped_data.rds")
```


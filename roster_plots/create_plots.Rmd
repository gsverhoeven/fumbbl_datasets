---
title: 'Create Blood Bowl roster plots'
author: "Gertjan Verhoeven & Hiliadan"
date: '2025-08-19'
params:
  group_name: "Super League S6"
  tournament_ruleset: "EB25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Creating the plots

I switched to R For further processing of the data (including clustering) and creating the final roster visualizations. Full code is available in `create_plots.Rmd`. Processing of the data involved:

* adding the cost for each player and inducement (yes, I typed together a file with the cost of all the BB2020 rosters!), 
* creating a table with all the skill colors, 
* removing the bribes from the inducements that originated from the "Get the ref" kickoff event (but keeping those that are part of the roster)
* applying a hierarchical clustering algorithm (`hclust_order()` from my own wrapper package `ggoheatmap`) to create a sort order for the rosters.

I used `ggplot` create the final plots. For ease of sharing, I created `roster_book.Rmd` that generates a PDF that contains all 29 plots.

# I. Loading package and data
## Load packages

```{r}
# Load packages
library(tidyverse)
library(gridExtra)
library(janitor)
library(reactable)
library(htmltools) # for tagList()
#devtools::install_github("kcuilla/reactablefmtr") # DO NOT USE THE CRAN VERSION IT IS OUTDATED, HOWEVER THIS VERSION ALSO HAS A BUG WITH A PR FIX OPEN
library(reactablefmtr) 
#devtools::install_github("gsverhoeven/ggoheatmap")
library(ggoheatmap)
source("helper_functions.R")
```

## Read prepped data

```{r}
df_rosters <- readRDS("work/df_rosters_prepped_data.rds")
df_rosters1 <- readRDS("work/df_rosters1_raw_data.rds")
group_name <- params$group_name
tournament_ruleset <- params$tournament_ruleset
races <- unique(df_rosters$roster.name)
```

# V. Display
## Hierarchical clustering

Delete the folder then recreates it, to ensure old pictures are not confused with the latest data

```{r folder cleaning}
#unlink(tournament_ruleset, recursive = TRUE)
#dir.create(tournament_ruleset)
```

## Create heatmap plots & add skill tables

```{r heatmap}
for(i in 1:1){
#for(i in 1:length(races)){
  race_name <- races[i]

  df <- df_rosters %>% 
    filter(is.na(banned_due_to_star_player) & is.na(banned_due_to_inducements) & is.na(banned_due_to_number_of_skills)) %>%
    filter(roster.name == race_name) %>%
    filter(!(position %in% c("cheerleaders", "assistantCoaches"))) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, number, skill_name, color) %>% # skill stacking
    summarise(cnt = max(cnt), cost = max(cost)) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, skill_name, color) %>%
    summarise(n = sum(cnt), cost = cost * sum(cnt)) %>%
    group_by(team_id, coach_name, position, sort_order, n) %>%
    summarise(nr = row_number(), skill_name = skill_name, color = color, cost = cost)

  # need at least two teams for clustering
  if(n_distinct(df$team_id) > 1 & n_distinct(df$cost) > 1){ # do clustering
    df <- df %>%
      mutate(position_unique = paste0(position, "_", nr)) %>%
      mutate(team_id_char = as.character(team_id)) %>%
      ungroup() %>%
      ggoheatmap::hclust_order(xvar = "team_id_char", 
                   yvar = "position_unique", 
                   value_var = "cost", dcast_fill = 1) %>%
      select(team_id, cluster_order) %>%
      distinct() %>%
      right_join(df, by = "team_id") 
  } else {
    df <- df %>%
      mutate(cluster_order = as.integer(as.factor(coach_name)))
  }
  df$coach_team_id <- paste0(df$coach_name, "_", str_sub(as.character(df$team_id)))
  

  # Wrap title to ensure it does not overlap with caption (e.g. for Imperial Nobility)
  plot_title <- stringr::str_wrap(paste0("FUMBBL ", group_name, " ", race_name, " rosters"), width = 35)
  
  
  gp <- ggplot(df, aes(x = reorder(factor(coach_team_id), cluster_order), y = reorder(paste(position, nr), -sort_order))) +
    geom_tile(aes(fill = color), color = "black") +
    geom_text(aes(label = n), color = "white") +
    scale_fill_identity(breaks = c(df$color),
                        labels = c(df$skill_name)) +
    coord_fixed() +
    theme(legend.position = "none") +
    ggtitle(plot_title) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(panel.background = element_rect(fill = "white")) +
    theme(plot.margin = ggplot2::margin(l = 0)) + # Set left margin to 0 to try to move to the left
    labs(x = "", y = "")

  #print(gp)
  
  # Sort skills alphabetically to display them sorted in the caption
  df <- df %>%
    arrange(skill_name)
  
  # Create a data frame for the legend
  legend_df <- df  %>%
    ungroup() %>% 
    select(skill_name, color) %>% 
    distinct(skill_name, color) 
    
  
  #print(legend_df)
  
    # Calculate the number of skills displayed to adapt the height for the ggsave (see below) and the width of the legend
  n_legend_items <- n_distinct(df$skill_name)
  
  # Generate a custom legend using ggplot
  legend_plot <- ggplot(legend_df, aes(x = 1, y = skill_name, fill = color)) +
    # The width is proportional to the number of items to display because for some reasons, the more the items, the smaller the width becomes in default settings
    geom_tile(color = "black", width = 2.8*n_legend_items/11) +
    # Add a shadow to make white (added on the following line) readable on light background. The nudge_x offset is there because for some reasons, the text is not aligned left, despite hjust = 0. It is proportional to the number of items because the bigger the width (proportional to the number of items), the bigger the disalignment
    geom_text(aes(label = skill_name), hjust = 0, color = "black", nudge_x = -1.4*n_legend_items/11-0.02, nudge_y = -0.02) + 
    geom_text(aes(label = skill_name), hjust = 0, color = "white", nudge_x = -1.4*n_legend_items/11) +
    scale_fill_identity() +
    coord_fixed() +
    theme_void() +
    theme(
      legend.position = "none",
      axis.text.y = element_blank(),
      axis.title = element_blank()
    )

  print("final plot")
  
  # Combine the main plot and custom legend
  final_plot <- gridExtra::grid.arrange(
    gp,                      # Main plot
    legend_plot,             # Custom legend
    ncol = 2,                # Arrange side by side
    widths = c(3, 1)         # Adjust width proportions
  )
  

  
  plotname <- paste0(tournament_ruleset, "/", group_name, "_roster_plot_", race_name, ".png")
  print(plotname)
  
  # Set dynamic height: Base height + extra height per legend item
  # 1 = 300 px, usually a race requires 1500px to be displayed properly
  base_height <- 6.30
  # A skill requires about 75px or 0.25 to be properly displayed
  extra_height_per_item <- 0.25
  # The base height of 6.25 allows to display properly about 20 skills (+ "Skills")
  dynamic_height <- base_height + max((n_legend_items-20), 0) * extra_height_per_item
  print(dynamic_height)

  ggsave(gsub(" ", "_", plotname), final_plot, width = 10, height = dynamic_height)
}
```

```{r}
# Initialize a list to store the skill tables
skill_table_list <- list()

for(i in 1:length(races)){
  race_name <- races[i]
  # Store skill tables for the race in a list (they can't be displayed within a for loop), they'll be displayed outside the loop all at once
  skill_table_list[[i]] <- make_skill_table(race_name, df_rosters1)
}
```


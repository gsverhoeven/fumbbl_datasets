---
title: 'Create Blood Bowl roster plots'
author: "Gertjan Verhoeven & Hiliadan"
date: '2025-01-26'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```

# Creating the plots

I switched to R For further processing of the data (including clustering) and creating the final roster visualizations. Full code is available in `create_plots.Rmd`. Processing of the data involved:

* adding the cost for each player and inducement (yes, I typed together a file with the cost of all the BB2020 rosters!), 
* creating a table with all the skill colors, 
* removing the bribes from the inducements that originated from the "Get the ref" kickoff event (but keeping those that are part of the roster)
* applying a hierarchical clustering algorithm (`hclust_order()` from my own wrapper package `ggoheatmap`) to create a sort order for the rosters.

I used `ggplot` create the final plots. For ease of sharing, I created `roster_book.Rmd` that generates a PDF that contains all 29 plots.

# Load packages

```{r warning=FALSE, message=FALSE}
# Load packages
library(tidyverse)
library(ggfortify)
library(ggrepel)
library(readODS)
library(gridExtra)
library(stringr)
```


# Read and prep the data

We start with reading in the scraped FUMBBL roster data, this is generated by the `fumbbl_rosters` Jupyter Notebook.


```{r}
df_rosters1 <- read.csv(file = "../datasets/v0.7/df_rosters_eb2025.csv")

df_rosters1$group_name <- "EB25 training"

group_name <- "EB25 training"

tournament_ruleset <- "EB25"

df_rosters <- df_rosters1 %>%
  filter(position != "") %>%
  mutate(cnt = 1) %>%
  rename(skill_name = name)
```

```{r}
# add xtra stuff
extra_stuff <- unique(df_rosters %>% 
                    mutate(apothecary = ifelse(apothecary == "Yes", 1, 0)) %>%
  select(group_name, team_id, roster.name, coach_name, rerolls, assistantCoaches, cheerleaders, apothecary) %>%
    pivot_longer(cols = -c(group_name, team_id, roster.name, coach_name), values_to = "cnt") %>%
    filter(cnt > 0) %>%
    mutate(position = name) %>%
    select(group_name, team_id, roster.name, coach_name, position, cnt) %>%
    # mutate(team_name = "") %>%
    mutate(player_id = 99999999) %>%
    mutate(number = 99) %>%
    mutate(skill_id = NA) %>%
    mutate(name = NA)) %>%
    rename(skill_name = name)

if ("team_name" %in% colnames(df_rosters)){ 
  extra_stuff <- extra_stuff %>%
    mutate(team_name = "")
}

df_rosters <- df_rosters %>%
  select(-c(X, rerolls, assistantCoaches, cheerleaders, apothecary))

df_rosters <- rbind(df_rosters, extra_stuff)
```



# Filter out "illegal" teams


```{r remove-illegal-teams}
# Exclude non valid rosters according to the ruleset

# Open the ruleset settings
allowed_inducements <- read_ods("bb_tournament_settings.ods", sheet="allowed_inducements") %>% 
  filter(Ruleset == tournament_ruleset)

banned_star_players <- read_ods("bb_tournament_settings.ods", sheet="banned_star_players") %>% 
  filter(Ruleset == tournament_ruleset)

other_settings <- read_ods("bb_tournament_settings.ods", sheet="other-settings") %>% 
  filter(Ruleset == tournament_ruleset)

max_skills <- other_settings %>%
  filter(`Other settings` == "Maximum number of same skill") %>%
  pull(Value) %>%
  as.numeric()

# Identify illegal teams

# ---  Due to banned star players ---
# Create a list of team_ids associated with banned star players
banned_teams_due_to_star_players <- df_rosters %>%
  semi_join(banned_star_players, by = c("position" = "Banned star players")) %>%
  distinct(team_id)

# Add a "banned" column to df_rosters and fill it
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_star_players %>% mutate(banned_due_to_star_player = TRUE), by = "team_id")

# ---  Due to inducements not in the list ---
# Create a regex pattern from allowed inducements
allowed_patterns <- paste(allowed_inducements$Inducements, collapse = "|")

# Create a list of team_ids associated with inducements not allowed
banned_teams_due_to_other_inducements <- df_rosters %>%
  # Keep only rows which are inducements, i.e. i) number = 99, ii) not empty, iii) is not a star player 
  filter(number == 99 & !is.na(position) & !startsWith(position, "Star player")) %>% 
  # If the inducement name (stored in position) is not within the allowed_patterns, then it's illegal
  filter(is.na(str_extract(position, regex(allowed_patterns, ignore_case = TRUE)))) 

# Inducements not allowed spotted
print(banned_teams_due_to_other_inducements %>% distinct(position))


banned_teams_due_to_other_inducements <- banned_teams_due_to_other_inducements %>%
  distinct(team_id)

head(banned_teams_due_to_other_inducements,20)


# Fill the "banned" column in df_rosters
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_other_inducements %>% mutate(banned_due_to_inducements = TRUE), by = "team_id")


display <- df_rosters %>% filter(banned_due_to_inducements == TRUE)
head(display, 20)

# ---  Due to number of illegal number of skills ---
# Would need to be improved to look at inherent skills AND "purchased" skills. Currently only look at "purchased" skills.

# Count the number of skills "purchased" per team
n_skills_per_team <- df_rosters %>%
  group_by(team_id, skill_name) %>% 
  filter(skill_name != "") %>% 
  summarize(n_skills = n(), .groups = "drop")

head(n_skills_per_team)

banned_teams_due_to_number_of_skills <- n_skills_per_team %>%
  filter(n_skills > max_skills) %>%
  distinct(team_id)

head(banned_teams_due_to_number_of_skills)

# Fill the "banned" column in df_rosters
df_rosters <- df_rosters %>%
  left_join(banned_teams_due_to_number_of_skills %>% mutate(banned_due_to_number_of_skills = TRUE), by = "team_id")


# --- Exclusion by hand (to deprecate) ---
df_rosters <- df_rosters %>%
  filter(!(team_id %in% c(1206955, 1209079)))


# Filter out BB2016 teams (Bretonnian)
df_rosters <- df_rosters %>%
  filter(roster.name != "Bretonnian")

```

# Label old and new amazon, and old and new norse rosters


```{r}
 old_amazon_team_ids <- df_rosters %>% filter(position == "Koka Kalim Blitzer") %>%
  filter(roster.name != "Amazon Eurobowl 2022") %>%
  group_by(team_id) %>%
  summarise(n()) %>%
  pull(team_id)
```   

```{r}
df_rosters <- df_rosters %>% 
  mutate(roster.name = ifelse(team_id %in% old_amazon_team_ids, "Amazon Team of Legend", roster.name))
```

There are also rosters with Norse Catcher AND Norse Raider. (old/new) march 2022, roster id 5144. This roster contains 

```{r}
 old_norse_team_ids <- df_rosters %>% filter(position %in% c("Norse Thrower", "Norse Catcher", "Norse Lineman")) %>%
  filter(roster.name != "Norse Eurobowl 2022") %>%
  group_by(team_id) %>%
  summarise(n()) %>%
  pull(team_id)
```

```{r}
df_rosters <- df_rosters %>% 
  mutate(roster.name = ifelse(team_id %in% old_norse_team_ids, "Norse Teams of Legend", roster.name))
```


```{r}
df_rosters %>% 
  filter(grepl("Amazon", roster.name)) %>%
  group_by(roster.name, position) %>%
  summarise(n = n())
```

# Check rosters without skills

```{r}
df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  mutate(has_skills = ifelse(n_skills == 0, 0, 1)) %>%
  group_by(group_name) %>%
  summarise(perc = mean(has_skills))
```

# Drop teams without skills.

```{r}
teams_to_drop <- df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  filter(n_skills == 0) %>%
  pull(team_id)

```
```{r}
df_rosters <- df_rosters %>%
  filter(!(team_id %in% teams_to_drop))
```


# Cleanup the skill names

```{r}
df_rosters <- df_rosters %>%
  mutate(skill_name = str_replace_all(skill_name, 
            pattern = "^_", replacement = "")) %>%
  mutate(skill_name = replace_na(skill_name, ""))
```


# condense skill stacking rows

A player with two skills has two rows, collapse into one, concatenating the two skills.
We sort by skill_id to avoid mirror combinations.

```{r}
df_rosters <- df_rosters %>%
  arrange(player_id, -skill_id) %>%
  group_by(across(c(-skill_id, -skill_name))) %>%
  summarise(skill_name = paste(skill_name, collapse = ""))

```
# wrangle bribes into cnt 0-3 bribes

Cannot easily seperate out the GEt the ref bribes from the  roster bribes

```{r}
df_rosters %>% 
  ungroup() %>%
  filter(grepl("bribe", position)) %>%
  distinct(position) %>%
  pull()

```

```{r}
df_rosters <- df_rosters %>%
  mutate(cnt = ifelse(grepl("bribe", position), as.integer(substr(position, 1, 2)), cnt)) %>%
  mutate(position = ifelse(grepl("bribes", position), "1 bribe", position)) 
```

# Open the skill color table

```{r}
skill_colors <- read_ods("230218 bb_skill_colors.ods")

skill_colors <- skill_colors %>%
  mutate(skill_name = replace_na(skill_name, "")) %>%
  select(-n)
```

# Produce stats on the number of skills in the teams assessed and check missing color in the color table

The skill_colors.ods should then be checked manually for any NA (or empty) in the color column. The rows concerned should be added to 230218 bb_skill_colors.ods

```{r}
skill_stats_and_missing_colors <- df_rosters %>%
  group_by(skill_name) %>%
  summarise(n = n()) %>% 
  full_join(skill_colors, by = "skill_name")


write_ods(skill_stats_and_missing_colors, "skill_colors.ods")
```



# create code list with roster cost

create empty list with all roster positions for each race
```{r}

out <- df_rosters %>%
  group_by(position, roster.name) %>%
  summarise(n = n())

```
manually fill in cost and sort order

# add codelist with roster cost

```{r}
cost <- read_ods("230217_bb_rosters_cost.ods")

cost <- cost %>%
  select(-n)
```

# check for missings

check if dataset has new positionals or star players etc.

```{r}
out <- out %>% 
  left_join(cost, by = c("position", "roster.name"))
```

```{r, eval = FALSE}
write_ods(out, "bb_rosters.ods")
```


```{r}
df_rosters <- df_rosters %>%
  left_join(cost, by = c("position", "roster.name"))
```


# Check team cost

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

res %>% filter(team_cost > 1150)

```

# remove bribes for TV >1150


all teams with 50 or 100 extra, remove 1 bribe ("get the ref" kick off result ends up on the match page)

```{r}
teams_get_the_ref <- res %>%
  filter(team_cost > 1150) %>%
  ungroup() %>%
  distinct(team_id) %>%
  pull()
```

reduce nr of bribes for get the ref teams with 1

<!-- So there are 22 get the ref teams -->

```{r}
df_rosters %>%
  ungroup() %>%
  filter(position == "1 bribe") %>%
  summarise(sum(cnt))
```
<!-- expect 45 - 22 = 23 bribes left -->

```{r}
# remove the get the ref bribes

df_rosters <- df_rosters %>%
  mutate(cnt = ifelse(team_id %in% teams_get_the_ref & position == "1 bribe", cnt - 1, cnt))

```


```{r}
df_rosters %>%
  ungroup() %>%
  filter(position == "1 bribe") %>%
  summarise(sum(cnt))
```
check!

drop rows with cnt 0

```{r}
df_rosters <- df_rosters %>% 
  filter(cnt != 0)
```


# Check total team cost again

Expect all teams at max 1150 or slightly below.

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

summary(res$team_cost)

```

```{r}
res %>% filter(team_cost < 1135)
```


```{r}
df_rosters <- df_rosters %>%
  left_join(skill_colors, by = "skill_name")
```


<!-- TEST CODE FOR CLUSTERING -->
# Hierarchical clustering

dataprep for HC.

```{r}
dir.create("EB25")
```

   
# Create heatmap plots

```{r heatmap}
# Uncomment to install on first use
#devtools::install_github("gsverhoeven/ggoheatmap")
library(ggoheatmap)

races <- unique(df_rosters$roster.name)

for(i in 1:length(races)){
  race_name <- races[i]

  df <- df_rosters %>% 
    filter(is.na(banned_due_to_star_player) & is.na(banned_due_to_inducements) & is.na(banned_due_to_number_of_skills)) %>%
    filter(roster.name == race_name) %>%
    filter(!(position %in% c("cheerleaders", "assistantCoaches"))) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, number, skill_name, color) %>% # skill stacking
    summarise(cnt = max(cnt), cost = max(cost)) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, skill_name, color) %>%
    summarise(n = sum(cnt), cost = cost * sum(cnt)) %>%
    group_by(team_id, coach_name, position, sort_order, n) %>%
    summarise(nr = row_number(), skill_name = skill_name, color = color, cost = cost)

  # check on at least 2 teams
  if(n_distinct(df$team_id) > 1 & n_distinct(df$cost) > 1){ # do clustering
    df <- df %>%
      mutate(position_unique = paste0(position, "_", nr)) %>%
      mutate(team_id_char = as.character(team_id)) %>%
      ungroup() %>%
      hclust_order(xvar = "team_id_char", 
                   yvar = "position_unique", 
                   value_var = "cost", dcast_fill = 1) %>%
      select(team_id, cluster_order) %>%
      distinct() %>%
      right_join(df, by = "team_id") 
  } else {
    df <- df %>%
      mutate(cluster_order = as.integer(as.factor(coach_name)))
  }
  df$coach_team_id <- paste0(df$coach_name, "_", str_sub(as.character(df$team_id)))
  # df$coach_team_id <- df$coach_name
  
  # Wrap title to ensure it does not overlap with caption (e.g. for Imperial Nobility)
  plot_title <- stringr::str_wrap(paste0("FUMBBL ", group_name, " ", race_name, " rosters"), width = 35)
  
  
  gp <- ggplot(df, aes(x = reorder(factor(coach_team_id), cluster_order), y = reorder(paste(position, nr), -sort_order))) +
    geom_tile(aes(fill = color), color = "black") +
    geom_text(aes(label = n), color = "white") +
    scale_fill_identity(breaks = c(df$color),
                        labels = c(df$skill_name)) +
    coord_fixed() +
    theme(legend.position = "none") +
    ggtitle(plot_title) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(panel.background = element_rect(fill = "white")) +
    theme(plot.margin = margin(l = 0)) + # Set left margin to 0 to try to move to the left
    labs(x = "", y = "")

  print(gp)
  
  # Sort skills alphabetically to display them sorted in the caption
  df <- df %>%
    arrange(skill_name)
  
  # Create a data frame for the legend
  legend_df <- df  %>%
    ungroup() %>% 
    select(skill_name, color) %>% 
    distinct(skill_name, color) 
    
  
  print(legend_df)
  
    # Calculate the number of skills displayed to adapt the height for the ggsave (see below) and the width of the legend
  n_legend_items <- n_distinct(df$skill_name)
  
  # Generate a custom legend using ggplot
  legend_plot <- ggplot(legend_df, aes(x = 1, y = skill_name, fill = color)) +
    # The width is proportional to the number of items to display because for some reasons, the more the items, the smaller the width becomes in default settings
    geom_tile(color = "black", width = 2.8*n_legend_items/11) +
    # Add a shadow to make white (added on the following line) readable on light background. The nudge_x offset is there because for some reasons, the text is not aligned left, despite hjust = 0. It is proportional to the number of items because the bigger the width (proportional to the number of items), the bigger the disalignment
    geom_text(aes(label = skill_name), hjust = 0, color = "black", nudge_x = -1.4*n_legend_items/11-0.02, nudge_7 = -0.02) + 
    geom_text(aes(label = skill_name), hjust = 0, color = "white", nudge_x = -1.4*n_legend_items/11) +
    scale_fill_identity() +
    coord_fixed() +
    theme_void() +
    theme(
      legend.position = "none",
      axis.text.y = element_blank(),
      axis.title = element_blank()
    )

  print(legend_plot)

  print("final plot")
  
  # Combine the main plot and custom legend
  final_plot <- grid.arrange(
    gp,                      # Main plot
    legend_plot,             # Custom legend
    ncol = 2,                # Arrange side by side
    widths = c(3, 1)         # Adjust width proportions
  )
  

  
  plotname <- paste0("EB25/", group_name, "_roster_plot_", race_name, ".png")
  print(plotname)
  
  # Set dynamic height: Base height + extra height per legend item
  # 1 = 300 px, usually a race requires 1500px to be displayed properly
  base_height <- 6.25
  # A skill requires about 75px or 0.25 to be properly displayed
  extra_height_per_item <- 0.25
  # The base height of 6.25 allows to display properly about 20 skills (+ "Skills")
  dynamic_height <- base_height + max((n_legend_items-20), 0) * extra_height_per_item
  print(dynamic_height)

  ggsave(gsub(" ", "_", plotname), final_plot, width = 10, height = dynamic_height)
}
```






